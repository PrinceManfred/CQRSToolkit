using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace CQRSToolkit.DependencyInjection.Generator
{
    [Generator]
    public class ServiceInjectionGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            var globalOptions = context.AnalyzerConfigOptions.GlobalOptions;

            string accessModifier = GetAccessModifier(globalOptions);
            string className = GetClassName(globalOptions);
            string outNamespace = GetNamespace(globalOptions);

            CQRSToolkitSyntaxReceiver? syntaxReceiver = (CQRSToolkitSyntaxReceiver?)context.SyntaxReceiver;
            if (syntaxReceiver is null) return;

            var injections = new StringBuilder();
            foreach(var target in syntaxReceiver.Classes)
            {
                var model = context.Compilation.GetSemanticModel(target.SyntaxTree);
                if (model.GetDeclaredSymbol(target) is not INamedTypeSymbol info
                    || info.IsValueType || info.IsAbstract || info.IsUnboundGenericType || info.AllInterfaces.Length == 0) continue;

                foreach(var candidate in info.AllInterfaces)
                {
                    var constructedName = candidate.ConstructedFrom.ToString();
                    if(constructedName == "CQRSToolkit.IQueryHandler<TQuery, TResponse>"
                    || constructedName == "CQRSToolkit.ICommandHandler<TCommand>"
                    || constructedName == "ICommandResponseHandler<TCommand, TResponse>")
                    {
                        injections.AppendLine($"\tservices.AddTransient(typeof({candidate}), typeof({info}));");
                    }
                }
            }
            if(injections.Length == 0) return;
            string source = $@"// <auto-generated/>
namespace {outNamespace}
{{
    {accessModifier} static partial class {className}
    {{
        public static Microsoft.Extensions.DependencyInjection.IServiceCollection AddCQRSToolkitGenerated(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)
        {{
        {injections}
            return services;
        }}
    }}
}}";
            context.AddSource("CQRSToolkit.DependencyInjection.Generator.g.cs", source);


        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new CQRSToolkitSyntaxReceiver());
        }

        private string GetAccessModifier(AnalyzerConfigOptions options)
        {
            string accessModifier = "internal";

            options.TryGetValue("build_property.CQRSToolkit_DIGen_AccessModifier", out var msBuildAccessModifier);
            if (msBuildAccessModifier is not null && msBuildAccessModifier.Trim() != "")
            {
                accessModifier = msBuildAccessModifier;
            }

            options.TryGetValue("CQRSToolkit_DIGen_AccessModifier", out var editorConfigAccessModifier);
            if (editorConfigAccessModifier is not null && editorConfigAccessModifier.Trim() != "")
            {
                accessModifier = editorConfigAccessModifier;
            }

            return accessModifier;
        }

        private string GetClassName(AnalyzerConfigOptions options)
        {
            string className = "CQRSServiceExtensions";

            options.TryGetValue("build_property.CQRSToolkit_DIGen_ClassName", out var msBuildClassName);
            if (msBuildClassName is not null && msBuildClassName.Trim() != "")
            {
                className = msBuildClassName;
            }

            options.TryGetValue("CQRSToolkit_DIGen_ClassName", out var editorConfigClassName);
            if (editorConfigClassName is not null && editorConfigClassName.Trim() != "")
            {
                className = editorConfigClassName;
            }

            return className;
        }

        private string GetNamespace(AnalyzerConfigOptions options)
        {
            string outNamespace = "CQRSToolkit.DependencyInjection";

            options.TryGetValue("build_property.CQRSToolkit_DIGen_Namespace", out var msBuildNamespace);
            if (msBuildNamespace is not null && msBuildNamespace.Trim() != "")
            {
                outNamespace = msBuildNamespace;
            }

            options.TryGetValue("build_property.CQRSToolkit_DIGen_Namespace", out var editorConfigNamespace);
            if (editorConfigNamespace is not null && editorConfigNamespace.Trim() != "")
            {
                outNamespace = editorConfigNamespace;
            }

            return outNamespace;
        }
    }

    class CQRSToolkitSyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> Classes { get; private set; } = new List<ClassDeclarationSyntax>();

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            // Business logic to decide what we're interested in goes here
            if (syntaxNode is ClassDeclarationSyntax cds)
            {
                Classes.Add(cds);
            }
        }
    }
}